<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>üé§ Real-Time Speech Recognition</title>
    <style>
        /* (same CSS as before ‚Äî omitted here for brevity in the comment, keep your original CSS) */
        * { margin:0; padding:0; box-sizing:border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display:flex;
            justify-content:center;
            align-items:center;
            padding:20px;
        }
        .container { background:white; border-radius:20px; box-shadow:0 20px 40px rgba(0,0,0,0.2); width:100%; max-width:900px; overflow:hidden; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; padding:30px; text-align:center; }
        .header h1 { font-size:2.5rem; margin-bottom:10px; }
        .header p { opacity:0.9; font-size:1.1rem; }
        .content { padding:30px; }
        .info-box { background:#e7f3ff; border-left:4px solid #2196F3; padding:15px; margin-bottom:20px; border-radius:0 5px 5px 0; }
        .warning-box { background:#fff3cd; border-left:4px solid #ffc107; padding:15px; margin-bottom:20px; border-radius:0 5px 5px 0; display:none; }
        .language-selector { margin-bottom:30px; }
        .language-selector label { display:block; margin-bottom:10px; font-weight:600; color:#333; font-size:1.1rem; }
        select { width:100%; padding:15px; border:2px solid #e0e0e0; border-radius:10px; font-size:1rem; background:white; cursor:pointer; transition:border-color 0.3s;}
        select:focus { outline:none; border-color:#667eea;}
        .recording-section { background:#f8f9fa; padding:30px; border-radius:15px; margin-bottom:30px; text-align:center; }
        .recording-section h3 { color:#333; margin-bottom:20px; font-size:1.5rem; }
        .record-btn { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; border:none; padding:20px 40px; font-size:1.2rem; border-radius:50px; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; gap:10px; transition:all 0.3s; font-weight:600; min-width:200px;}
        .record-btn:hover { transform:translateY(-2px); box-shadow:0 10px 20px rgba(102,126,234,0.3); }
        .record-btn.recording { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); animation:pulse 1.5s infinite; }
        @keyframes pulse { 0%{transform:scale(1);} 50%{transform:scale(1.05);} 100%{transform:scale(1);} }
        .record-btn:disabled { opacity:0.6; cursor:not-allowed; transform:none !important; box-shadow:none !important; }
        .upload-section { background:#f8f9fa; padding:30px; border-radius:15px; text-align:center; }
        .upload-section h3 { color:#333; margin-bottom:20px; font-size:1.5rem; }
        .file-input { margin-bottom:20px; }
        .file-input input[type="file"] { width:100%; padding:15px; border:2px dashed #667eea; border-radius:10px; background:white; cursor:pointer; }
        .upload-btn { background:#4CAF50; color:white; border:none; padding:15px 30px; font-size:1.1rem; border-radius:10px; cursor:pointer; transition:all 0.3s; font-weight:600; }
        .upload-btn:hover { background:#45a049; transform:translateY(-2px); }
        .result-section { margin-top:30px; padding:30px; background:#f8f9fa; border-radius:15px; }
        .result-section h3 { color:#333; margin-bottom:20px; font-size:1.5rem; }
        #resultText { background:white; padding:20px; border-radius:10px; min-height:100px; border:2px solid #e0e0e0; font-size:1.1rem; line-height:1.6; white-space:pre-wrap; word-wrap:break-word; }
        .loading { display:none; text-align:center; padding:20px; color:#667eea; font-size:1.2rem; }
        .loading span { display:inline-block; animation:dots 1.5s infinite; }
        @keyframes dots { 0%,20%{ content:'.'; } 40%{ content:'..'; } 60%,100%{ content:'...'; } }
        .status { padding:15px; border-radius:10px; margin-top:20px; display:none; font-weight:600; }
        .status.success { background:#d4edda; color:#155724; border:1px solid #c3e6cb; }
        .status.error { background:#f8d7da; color:#721c24; border:1px solid #f5c6cb; }
        @media (max-width:768px){ .container{margin:10px;} .header h1{font-size:2rem;} .content{padding:20px;} .record-btn, .upload-btn{width:100%;} }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé§ Real-Time Speech Recognition</h1>
            <p>Speak in your preferred language and see it converted to text instantly!</p>
        </div>

        <div class="content">
            <div class="info-box">
                <strong>üì¢ Instructions:</strong> Select your language, then either record using microphone or upload an audio file.
            </div>

            <div class="warning-box" id="ffmpegWarning">
                <strong>‚ö†Ô∏è Important:</strong> FFmpeg is not installed. Please install FFmpeg for recording to work properly.
                <br/><br/>
                <a href="https://www.gyan.dev/ffmpeg/builds/" target="_blank" style="color:#2196F3; text-decoration:underline;">üîó Download FFmpeg here</a>
            </div>

            <div class="language-selector">
                <label for="languageSelect">Select Language:</label>
                <select id="languageSelect">
                    <option value="en-IN">English (India)</option>
                    <option value="en-US">English (US)</option>
                    <option value="hi-IN">Hindi (India)</option>
                    <option value="mr-IN">Marathi (India)</option>
                    <option value="ta-IN">Tamil (India)</option>
                    <option value="te-IN">Telugu (India)</option>
                    <option value="kn-IN">Kannada (India)</option>
                    <option value="ml-IN">Malayalam (India)</option>
                    <option value="bn-IN">Bengali (India)</option>
                    <option value="gu-IN">Gujarati (India)</option>
                    <option value="pa-IN">Punjabi (India)</option>
                </select>
            </div>

            <div class="recording-section">
                <h3>üé§ Record with Microphone</h3>
                <button id="recordBtn" class="record-btn" onclick="toggleRecording()">
                    <span id="recordIcon">üé§</span>
                    <span id="recordText">Start Recording</span>
                </button>
                <div id="recordingStatus" style="margin-top:15px; color:#666;"></div>
            </div>

            <div class="upload-section">
                <h3>üìÅ Upload Audio File</h3>
                <div class="file-input">
                    <input type="file" id="audioFile" accept="audio/*" />
                </div>
                <button class="upload-btn" onclick="uploadAudio()">Upload &amp; Transcribe</button>
                <p style="margin-top:10px; font-size:0.9rem; color:#666;">
                    Supports: WAV, MP3, M4A, WEBM formats
                </p>
            </div>

            <!-- Loading and processing details -->
            <div class="loading" id="loading"><div>Processing your audio<span>...</span></div></div>
            <div id="processingDetails" style="margin-top:10px; font-size:0.95rem; color:#666;"></div>

            <div class="status" id="status"></div>

            <div class="result-section">
                <h3>üìù Transcription Result</h3>
                <div id="resultText">Your transcribed text will appear here...</div>
                <div id="resultInfo" style="margin-top:15px; font-size:0.9rem; color:#666;"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let ffmpegAvailable = false;

        const recordBtn = document.getElementById('recordBtn');
        const recordIcon = document.getElementById('recordIcon');
        const recordText = document.getElementById('recordText');
        const recordingStatus = document.getElementById('recordingStatus');
        const ffmpegWarning = document.getElementById('ffmpegWarning');

        // NEW: processingDetails element to avoid ReferenceError
        const processingDetails = document.getElementById('processingDetails');

        // Check if browser supports audio recording
        function checkRecordingSupport() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                recordBtn.disabled = true;
                recordText.textContent = 'Recording Not Supported';
                recordingStatus.textContent = 'Your browser does not support audio recording. Please use Chrome, Firefox, or Edge.';
                recordingStatus.style.color = '#f5576c';
                return false;
            }
            return true;
        }

        // Initialize on page load
        window.addEventListener('load', function() {
            checkRecordingSupport();

            // Check server status and ffmpeg availability
            fetch('/test')
                .then(response => response.json())
                .then(data => {
                    console.log('Server status:', data);
                    ffmpegAvailable = data.ffmpeg_available;

                    if (!ffmpegAvailable) {
                        ffmpegWarning.style.display = 'block';
                        showStatus('‚ö†Ô∏è FFmpeg not found. Recording may not work properly. Please install FFmpeg.', 'error');
                    }
                })
                .catch(error => {
                    console.error('Server check failed:', error);
                    showStatus('Cannot connect to server. Make sure the Flask app is running.', 'error');
                });
        });

        // Toggle recording
        async function toggleRecording() {
            if (!checkRecordingSupport()) return;

            if (!ffmpegAvailable) {
                if (!confirm('FFmpeg is not installed. Recording may not work properly. Continue anyway?')) {
                    return;
                }
            }

            if (!isRecording) {
                // Start recording
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 16000
                        }
                    });

                    mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });

                    audioChunks = [];

                    mediaRecorder.ondataavailable = event => {
                        if (event.data && event.data.size > 0) audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = async () => {
                        // Create audio blob
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });

                        // Stop all tracks
                        try {
                            stream.getTracks().forEach(track => track.stop());
                        } catch (e) {
                            // ignore
                        }

                        // Send to server
                        await sendRecordingToServer(audioBlob);
                    };

                    // Start recording
                    mediaRecorder.start();
                    isRecording = true;

                    // Update UI
                    recordIcon.textContent = '‚èπÔ∏è';
                    recordText.textContent = 'Stop Recording';
                    recordBtn.classList.add('recording');
                    recordingStatus.textContent = 'Recording... Speak now!';
                    recordingStatus.style.color = '#f5576c';

                    // Auto-stop after 30 seconds
                    setTimeout(() => {
                        if (isRecording && mediaRecorder && mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                            isRecording = false;
                            recordIcon.textContent = 'üé§';
                            recordText.textContent = 'Start Recording';
                            recordBtn.classList.remove('recording');
                            recordingStatus.textContent = 'Recording stopped automatically after 30 seconds.';
                            recordingStatus.style.color = '#666';
                        }
                    }, 30000);

                } catch (error) {
                    console.error('Recording error:', error);

                    if (error.name === 'NotAllowedError') {
                        showStatus('Microphone access was denied. Please allow microphone access in your browser settings.', 'error');
                    } else if (error.name === 'NotFoundError') {
                        showStatus('No microphone found. Please connect a microphone and try again.', 'error');
                    } else {
                        showStatus('Error accessing microphone: ' + (error.message || error), 'error');
                    }

                    recordBtn.disabled = true;
                    recordText.textContent = 'Microphone Error';
                }
            } else {
                // Stop recording
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    isRecording = false;

                    // Update UI
                    recordIcon.textContent = 'üé§';
                    recordText.textContent = 'Start Recording';
                    recordBtn.classList.remove('recording');
                    recordingStatus.textContent = 'Processing your recording...';
                    recordingStatus.style.color = '#4CAF50';
                }
            }
        }

        // Handle file upload
        async function uploadAudio() {
            const fileInput = document.getElementById('audioFile');
            if (!fileInput.files || !fileInput.files[0]) {
                showStatus('Please select an audio file first.', 'error');
                return;
            }

            const audioFile = fileInput.files[0];

            // Validate file size (max 10MB)
            if (audioFile.size > 10 * 1024 * 1024) {
                showStatus('File size too large. Please select a file smaller than 10MB.', 'error');
                return;
            }

            await sendFileToServer(audioFile);
        }

        // Send recording to server
        async function sendRecordingToServer(audioBlob) {
            const language = document.getElementById('languageSelect').value;
            const formData = new FormData();
            formData.append('audio_data', audioBlob, 'recording.webm');
            formData.append('language', language);

            await sendToServer(formData, 'record');
        }

        // Send file to server
        async function sendFileToServer(audioFile) {
            const language = document.getElementById('languageSelect').value;
            const formData = new FormData();
            formData.append('audio_file', audioFile);
            formData.append('language', language);

            await sendToServer(formData, 'upload');
        }

        // Common function to send data to server
        async function sendToServer(formData, endpoint) {
            // Show loading with details
            document.getElementById('loading').style.display = 'block';
            document.getElementById('status').style.display = 'none';
            document.getElementById('resultText').textContent = 'Processing... Please wait.';
            document.getElementById('resultInfo').textContent = '';
            processingDetails.textContent = '';

            // Show processing details
            if (endpoint === 'record') {
                processingDetails.textContent = 'Converting and transcribing your recording...';
            } else {
                const file = formData.get('audio_data') || formData.get('audio_file');
                let fileName = 'audio file';
                // Blob/File objects may not always have 'name', be defensive
                try {
                    if (file && file.name) fileName = file.name;
                    else if (file && file instanceof Blob && file.size) fileName = 'uploaded_audio';
                } catch (e) {
                    // ignore and use default
                }
                processingDetails.textContent = `Processing ${fileName}... This may take a moment for long files.`;
            }

            try {
                const response = await fetch(`/${endpoint}`, {
                    method: 'POST',
                    body: formData
                });

                // Try to parse JSON; if server returns non-json, catch it
                let data;
                try {
                    data = await response.json();
                } catch (parseErr) {
                    throw new Error('Invalid JSON response from server');
                }

                if (data.status === 'success') {
                    // Show success status
                    let successMessage = `‚úÖ Successfully transcribed ${data.language || 'audio'}`;
                    if (data.chunks_processed) {
                        successMessage += ` (processed in ${data.chunks_processed} chunks)`;
                    }
                    showStatus(successMessage, 'success');

                    // Display result
                    document.getElementById('resultText').textContent = data.text || '';

                    // Show additional info
                    let info = '';
                    if (data.language) info += `Language: ${data.language} | `;
                    if (data.filename) info += `File: ${data.filename} | `;
                    if (data.file_size) {
                        const sizeMB = (data.file_size / (1024 * 1024)).toFixed(2);
                        info += `Size: ${sizeMB} MB | `;
                    }
                    if (data.processing_note) info += `${data.processing_note} | `;
                    info += `Characters: ${data.text ? data.text.length : 0} | Words: ${data.text ? data.text.split(/\s+/).filter(Boolean).length : 0}`;
                    document.getElementById('resultInfo').textContent = info;

                    // Enable text selection and copying
                    document.getElementById('resultText').style.userSelect = 'text';

                } else {
                    // Show error
                    showStatus('‚ùå ' + (data.message || 'Processing failed'), 'error');
                    document.getElementById('resultText').textContent = 'Error occurred during processing.';
                }
            } catch (error) {
                console.error('Server error:', error);
                showStatus('‚ùå Network error: ' + (error.message || error), 'error');
                document.getElementById('resultText').textContent = 'Could not connect to server.';
            } finally {
                // Hide loading
                document.getElementById('loading').style.display = 'none';
                processingDetails.textContent = '';
            }
        }

        // Show status message
        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';

            // Auto-hide after 5 seconds (unless it's an important warning)
            if (type !== 'error' || !message.includes('FFmpeg')) {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        // Update file info when selected
        document.getElementById('audioFile').addEventListener('change', function(e) {
            if (this.files && this.files[0]) {
                const fileName = this.files[0].name;
                const fileSize = (this.files[0].size / (1024 * 1024)).toFixed(2);
                const fileType = this.files[0].type || 'audio file';

                // Create or update file info display
                let fileInfo = document.getElementById('fileInfo');
                if (!fileInfo) {
                    fileInfo = document.createElement('div');
                    fileInfo.id = 'fileInfo';
                    fileInfo.style.marginTop = '10px';
                    fileInfo.style.fontSize = '0.9rem';
                    fileInfo.style.color = '#666';
                    this.parentNode.appendChild(fileInfo);
                }

                fileInfo.innerHTML = `Selected: ${fileName} (${fileSize} MB, ${fileType})`;
            }
        });
    </script>
</body>
</html>
